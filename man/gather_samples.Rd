% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gather_samples.R
\name{gather_samples}
\alias{extract_samples}
\alias{gather_samples}
\alias{tidy_samples}
\title{Gather samples from a Bayesian sampler in a tidy data format}
\usage{
gather_samples(model, ...)
}
\arguments{
\item{model}{A supported Bayesian model fit / MCMC object. Currently
supported models include \code{\link[coda]{mcmc}}.}

\item{...}{Expressions in the form of
\code{variable_name[index_1, index_2, ...] | wide_index}. See `Details`.}
}
\value{
A data frame.
}
\description{
Extract samples from a Bayesian/MCMC sampler for a variable with the given named
indices into a long-format data frame.
}
\details{
Imagine a JAGS or Stan fit named \code{fit}. The model may contain a variable named 
\code{b[i,v]} (in the JAGS or Stan language) with \code{i} in \code{1:100} and \code{v} in \code{1:3}.
However, samples returned from JAGS or Stan in R will not reflect this indexing structure, instead
they will have multiple columns with names like \code{"b[1,1]"}, \code{"b[2,1]"}, etc.

\code{gather_samples} provides a straightforward syntax to translate these columns back into
properly-indexed variables in a tidy (long-format) data frame, optionally recovering
index types (e.g. factor levels) as it does so.

\code{gather_samples} returns data frames already grouped by all indices used on the variables you specify.

For example, \code{gather_samples(fit, b[i,v])} would return a grouped
data frame (grouped by \code{i} and \code{v}), with:
\itemize{
     \item column \code{".chain"}: the chain number 
     \item column \code{".iteration"}: the interation number
     \item column \code{"i"}: value in \code{1:20}
     \item column \code{"v"}: value in \code{1:3}
     \item column \code{"b"}: value of \code{"b[i,v]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
 }

\code{gather_samples} can use type information applied to the \code{fit}
object by \code{\link{recover_types}} to convert columns back into their
original types. This is particularly helpful if some of the indices in
your model were originally factors. For example, if the \code{v} index
in the original data frame \code{data} was a factor with levels \code{c("a","b","c")},
then we could use \code{recover_types} before \code{gather_samples}:

\preformatted{fit \%>\%
    recover_types(data) %\>\%
    gather_samples(fit, b[i,v])
 }
 
Which would return the same data frame as above, except the \code{"v"} column
would be a value in \code{c("a","b","c")} instead of \code{1:3}.

For variables that do not share the same subscripts (or share
some but not all subscripts), we can supply their specifications separately. 
For example, if we have a variable d[i] with the same i subscript 
as b[i,v], and a variable x with no subscripts, we could do this:

\preformatted{gather_samples(fit, x, d[i], b[i,v])}

Which is roughly equivalent to this:

\preformatted{gather_samples(fit, x) \%>\%
    inner_join(gather_samples(fit, d[i])) \%>\%
    inner_join(gather_samples(fit, b[i,v])) \%>\%
    group_by(i,v)
}

The \code{c} function can be used to combine multiple variable names that have 
the same indices. For example, if we have several variables with the same
subscripts \code{i} and \code{v}, we could do this:

\preformatted{gather_samples(fit, c(w, x, y, z)[i,v])}

Which is roughly equivalent to this:

\preformatted{gather_samples(fit, w[i,v], x[i,v], y[i,v], z[i,v])}

Besides being more compact, the \code{c()}-style syntax is currently also
faster (though that may change).

Indices can be omitted from the resulting data frame by leaving their names
blank; e.g. \code{gather_samples(fit, b[,v])} will omit the first index of
\code{b} from the output. This is useful if an index is known to contain all
the same value in a given model.

The shorthand \code{..} can be used to specify one column that should be put
into a wide format and whose names will be the base variable name, plus a dot
("."), plus the value of the index at \code{..}. For example:

\code{gather_samples(fit, b[i,..])} would return a grouped data frame
(grouped by \code{i}), with:
\itemize{
     \item column \code{".chain"}: the chain number 
     \item column \code{".iteration"}: the interation number
     \item column \code{"i"}: value in \code{1:20}
     \item column \code{"b.1"}: value of \code{"b[i,1]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
     \item column \code{"b.2"}: value of \code{"b[i,2]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
     \item column \code{"b.3"}: value of \code{"b[i,3]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
 }

An optional clause in the form \code{| wide_index} can also be used to put
the data frame into a wide format based on \code{wide_index}. For example, this:

\preformatted{gather_samples(fit, b[i,v] | v)}

is roughly equivalent to this:

\preformatted{gather_samples(fit, b[i,v]) \%>\% spread(v,b)}

The main difference between using the \code{|} syntax instead of the
\code{..} syntax is that the \code{|} syntax respects prototypes applied to
indices with \code{\link{recover_types}}, and thus can be used to get
columns with nicer names. For example:

\code{fit \%>\% recover_types(data) \%>\% gather_samples(fit, b[i,v] | v)} would return a grouped data frame
(grouped by \code{i}), with:
\itemize{
     \item column \code{".chain"}: the chain number 
     \item column \code{".iteration"}: the interation number
     \item column \code{"i"}: value in \code{1:20}
     \item column \code{"a"}: value of \code{"b[i,1]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
     \item column \code{"b"}: value of \code{"b[i,2]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
     \item column \code{"c"}: value of \code{"b[i,3]"} for iteration number
         \code{".iteration"} on chain number \code{".chain"}
 }
}
\examples{

##TODO

}
\author{
Matthew Kay
}
\seealso{
\code{\link{recover_types}}, \code{\link{compose_data}}.
}
\keyword{manip}

